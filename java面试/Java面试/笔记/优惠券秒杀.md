# 全局ID生成器

看下我们的系统ID是如何生成的；
![[Pasted image 20231223141826.png]]

# 全局ID生成策略
## UUID

## Redis自增策略
每天一个Key，方便统计订单量
ID构造是时间戳+计数器的方式

## snowflake算法


# 添加优惠券
两种类型

# 下单功能
下单时需要判断两点：
- 秒杀是否开始或者结束，如果尚未开始或者已经结束都无法下单
- 库存是否充足，不足则无法下单


# 秒杀
## 超卖问题
高并发问题，常见解决方案就是加锁：


## 悲观锁
认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。
例如Synchronized、Lock都属于悲观锁。

## 乐观锁
认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据做了修改。
- 如果没有修改，则认为是安全的，自己更新数据。
- 如果已经被其他线程修改说明发生了安全问题，因此可以重试或者报异常

### 版本号法
基于数据的版本号判断是否被修改

### CAS法
用数据本身是否变化来代替版本的变化

# 分布式锁
满足分布式系统或者集群模式下多进程可见并且互斥的锁
Redis使用setnx的互斥命令来实现
需要实现两个方法
- 获取锁
	- 互斥：确保只有一个线程能够获取锁
	- 非阻塞：尝试一次，成功返回true，失败返回false
	- setnx lock thread1
	- expire lock 5
	- 上面两条命令可以放到一条语句中执行
	- set lock thread1 ex 10 nx
- 释放锁
	- 手动释放
	- 超时释放：获取锁时加一个超时时间
	- del key
![[Pasted image 20231223211424.png]]

## 实现
```java
public interface ILock {
	boolean tryLock(long timeoutSec); // timeoutSec 是过期时间
	void unlock();
}
```
![[Pasted image 20231223212605.png]]

## 释放锁的问题
释放锁的时候要判断是不是自己的标识；
不然会出现释放别人锁的情况；

## 基于Redis实现分布式锁
- 利用set nx ex获取锁，并设置过期时间，保存线程标识
- 释放锁时先判断线程标识是否和自己一致，一致的话才删除锁
特性：
- 利用set nx 保证互斥
- 利用set ex保证故障时锁依然能释放，避免死锁，提高安全性
- 利用Redis集群保证高可用和高并发特性

# 基于Redis的分布式锁优化
## 使用Redisson
### 引入依赖
### 配置客户端
![[Pasted image 20231223224542.png]]

### 使用
![[Pasted image 20231223224604.png]]

# Redis可以做消息队列
但是这里不用这个，最好还是看下kafka；因为项目里面用的kafka；








