# 概述
之前的时候，说是在可重复读隔离级别下，事务启动的时候会创建一个视图。然后在事务执行期间，即使有其他事务修改了数据，这个事务也是不感知的。

但是在行锁的情况下，如果事务之间需要竞争同一个锁的话，那么就不能这样了。它必须进入等待状态，等待其他事务释放锁

begin和start transaction并不是一个事务的起点，在执行到他们之后的第一个操作InnoDB表的数据，事务才算真正启动。但是想立即启动也可以，使用start transaction with consistent snapshot命令。

![[Pasted image 20240103222346.png]]
结论：
B查到的结果是3，A查到的结果是1；

## 解释
MySQL中有两个视图的概念
- 一个是view，这是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果
- 一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC和RR隔离级别的实现，它没有物理结构，仅仅用于在事务执行期间定义“我能看到什么数据”

## MVCC
在RR隔离级别下，事务在启动的时候就“拍了个快照”。这个快照是基于整库的。
### 快照实现
InnoDB里面每个事务都有一个事务ID，叫做transaction ID，是在事务开始的时候向InnoDB的事务系统申请的，并且严格递增。

表中的每行数据，都有多个版本，每个版本都有对应的row trx_id
![[Pasted image 20240103224546.png]]
图中的三个虚线箭头，就是undo log，而V1，V2，V3都不是真实存在的，都是要的时候根据undo log 计算出来

InnoDB如何做全库快照？
按照RR的定义，只要一个事务启动的时候声明：以我启动的时间为准，如果一个数据版本是在我启动之前就生成的，那么我认，如果是在我启动以后才生成的，那么我就不认，必须找它的上一个版本，当然自己更新的数据，肯定是认的。

实现上来讲，InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在活跃的所有事务ID，活跃指的是启动了但是还没提交。

数组里面事务ID最小的值记为“低水位”，当前系统里面已经创建过的事务ID的最大值加1记录为“高水位”
这个视图数组和高水位，组成了当前事务的一致性视图。

数据版本的可见性规则就是基于数据的row trx_id跟这个一致性视图对比得出来的。
![[Pasted image 20240103225249.png]]
对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能
- 落在绿色部分：表示是已经提交的事务或者是事务自己生成的，这是可见的
- 落在红色部分：表示这个版本是由将来启动的事务生成的，是不可见的
- 如果落在黄色部分：
	- 若row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见
	- 若row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见

InnoDB利用了“所有数据都有多个版本”特性，实现了“秒级创建快照”的能力

### 结论
一个数据版本，对于一个事务视图来说，除了自己更新的总是可见之外，有三种情况
- 版本未提交，不可见
- 版本已提交，但是在视图创建后提交的，不可见
- 版本已提交，但是在视图创建之前提交的，可见


更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”

可重复读的核心就是一致性读，而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，那么就会进入锁等待

# 总结
对于可重复读，查询只承认在事务启动前就已经提交完成的数据
对于读提交，查询只承认在语句启动前就已经提交完成的数据
而当前读，总是读取已经提交完成的最新版本




