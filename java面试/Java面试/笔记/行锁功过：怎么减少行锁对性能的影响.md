## 概述
MySQL的行锁是由存储引擎自己实现的。并不是所有存储引擎都支持行锁。MyISAM就不支持；
在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就释放，而是要等到事务提交才会自动释放，这就是两阶段锁协议；
如果事务中需要锁多个行，那么就把最容易出现冲突的语句往后放；

## 死锁和死锁检测
发生死锁后的策略：
- 直接进入等待，知道超时；这个超时参数可以通过innodb_lock_wait_timeout来设置
- 发起死锁检测，发现死锁后，主动回滚其中的某一个事务，参数是innodb_deadlock_detect设置为on，表示开启这个逻辑

上面那个参数默认是50s，对于业务上来讲，这个时间太长了，但是又不能很小，因为会出现很多不是死锁的情况被认为是死锁

正常的话采取第二种策略
但是死锁检测会耗费大量的CPU资源。如果1000个事务都是想更新同一行的话，那么死锁检测的量级就是1000000这个级别的

正常是可以将电影院的总金额分成好几份，然后更新的时候不要只更新同一行


