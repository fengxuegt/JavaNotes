# ACID
原子性、一致性、隔离性、持久性

## 隔离性
四种隔离级别
### 读未提交
read uncommited
A事务未提交，其他事务B就能看到A做的数据变更
### 读已提交
read commit
只有A事务提交，其他事务B才能看到A做的数据变更
### 可重复读
repeatable read 
一个事务在执行过程中看到的数据，总是跟这个事务在启动的时候看到的数据是一致的
### 可串行化
serializable
这个就代表直接加锁了，只有一个事务完成之后，其他事务才能再执行；

## 实现上
数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。
在可重复读级别下，这个视图是在事务启动时创建的，整个事务存在期间都是用这个视图。
在读已提交级别下，这个视图是每个SQL语句开始执行的时候创建的
读未提交级别下，直接返回记录上的最新值，没有视图概念
串行化的情况下，是直接用加锁的方式来处理的

Oracle默认的隔离级别是读已提交；因此对于一些从Oracle迁移到MySQL的应用，也要将MySQL的默认隔离级别设置成读已提交；

配置的方式是将启动参数transaction-isolation的值设置成read-commited。

可重复读适合什么样的场景呢？
进行数据校对的时候，不希望新的记录对校对结果产生影响。

## 具体实现
展开说明可重复读。
在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。
![[Pasted image 20231230162715.png]]
当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图ABC里面，这个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制MVCC。对于视图A，要得到1，就必须将当前值依次执行回滚操作得到。

回滚日志总不能一直保留吧？什么时候删掉呢？
在不需要它的时候就删掉，什么是不需要的时候？
那就是没有比它更早的read-view的时候

### 为什么尽量不要使用长事务
因为长事务意味着系统中会存在很多很老的事务视图。这些视图有可能访问数据库里的任何数据，那么在这个事务提交之前，数据库里它可能用到的所有回滚日志都必须保留，这就会导致大量占用存储空间。
以前的版本的时候，回滚日志和数据字典是一起放在ibdata里面的，因此长事务被提交，回滚段被清理，但是日志不会清理，所以导致空间占用越来越大；

而且长事务还会占用锁资源。

# 事务的启动方式
很多都是意外的长事务。
- 显示启动事务语句，begin或者start transaction。配套的提交语句是commit，回滚语句是rollback
- set autocommit = 0；这个命令会将线程的自动提交关闭。意味着只要执行一条select语句，事务就启动了，并且并不会自动提交。这个事务会持续存在直到你主动执行commit语句或者rollback或者断开连接；

有些客户端连接框架会默认连接成功后先执行一个set autommit = 0的命令，这就导致接下来的动作都在事务中，如果是长连接，就会导致长事务。

因此，一般建议使用set autocommit = 1；然后通过显示语句的方式来启动事务。

![[Pasted image 20231230164257.png]]
