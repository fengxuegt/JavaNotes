# 全局锁
全局锁就是对整个数据库实例加锁。
MySQL提供了一个加全局读锁的方法，命令是Flush tables with read lock（FTWRL）。
全局锁的典型使用场景就是，做全库逻辑备份。

可以在可重复读隔离级别下开启一个事务；具体操作方式就是：
使用官方自带的逻辑备份工具mysqldump，当mysqldump使用参数-single-transaction的时候，导数据之前就会启动一个事务，来确保一致性视图。由于MVCC的支持，这个过程是可以正常更新的。

一致性读固然是好的，但是前提是存储引擎要支持这个隔离级别。像MyISAM这种存储引擎，事务都不支持，也就无法实现这一功能。
这个时候就只能使用FTWRl了。
所以，single-transaction方法只适用于所有的表使用事务引擎的库。如果有的表使用了不 支持事务的引擎，那么备份就只能通过FTWRL方法。

### 既然要全库只读，为什么不使用set global readonly=true的方式呢？
- 在有些系统中，readonly的值会被用来做其他逻辑，比如判断一个库是主库还是从库。因此修改global的方式影响面太大；
- FTWRL方式如果出现异常，MySQL会自动释放这个全局锁；但是readonly这种方式，如果客户端发生异常的话，数据库会一直处于readonly状态，风险较高


# 表级锁
表级别的锁有两种：
- 表锁
- 元数据锁（MDL）

## 表锁
基本语法是 lock tables xxx read/write；释放的话是unlock tables
举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读 写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操 作。连写t1都不允许，自然也不能访问其他表。

## MDL
自动添加的；在对一个表做增删改查操作的时候，加MDL读锁。当对表结构做变更操作的时候，加MDL写锁。
- 读锁之间不互斥
- 读写锁和写锁之间是互斥的

MDL所是系统自动添加的，但是要注意一个机制:
事务中的MDL锁，会在语句执行开始时申请，但是语句执行结束后并不会马上释放，而是会等到整个事务提交之后再释放。
也就是说如果在事务A中一开始执行了select from t；然后另外的session要给t加字段，只能等着事务A结束，这个过程中，其他session也不能读t，等于事务A结束之前，啥都不能干了；

因此，如果有长事务的时候如何给表加字段？
- 如果在做DDL变更的时候正好有长事务在执行，要考虑先暂停DDL，或者kill掉长事务；
但是如果要变更的是一个热点表，kill掉一个长事务，新的事务请求马上就来了。比较理想的机制就是alter table语句里设置等待时间，如果在指定的等待时间里能够拿到MDL写锁最好，拿不到也别影响后面的业务语句。之后可以再重试。