# 覆盖索引
当索引覆盖了查询要求的时候我们就称之为覆盖索引。
由于覆盖索引可以减少树的搜索次数，显著提高性能，因此使用覆盖索引是一个常用的性能优化手段。
高频请求根据身份证号来查询姓名时，建立身份证号和姓名的联合索引就很有必要了。
建立冗余索引来支持覆盖索引时要权衡考虑；

# 最左前缀原则
B+树这种结构，支持根据索引的“最左前缀”，来定位记录。
举例：
假设有个name+age的联合索引；
![[Pasted image 20231230223822.png]]
可以看到，索引项是根据索引里面出现的字段顺序来排序的。
查询所有名字为张三的人：快速定位到D4，然后向后遍历得到结果；
查询名字第一个字是张的人：也能够用到这个索引；
因此，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以认为是联合索引的最左N个字段，也可以认为是最左M个字符；

## 联合索引内部的字段顺序
评估标准是索引的复用能力。因为可以支持最左前缀，所以当已经有了a，b这个联合索引之后就不需要再单独为a建立索引了；因此第一原则就是，如果通过调整顺序，可以少维护一个索引，那么这种顺序往往就是需要优先采用的；

那么如果既有联合查询，又有a，b各自的查询呢？
这个时候的考虑原则就是空间了，如果a  >  b，那么就建立（a，b）和b

# 索引下推
在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

```sql
select * from tuser where name like '张%' and age=10 and ismale=1;
```

(name,age)有联合索引；
## 没有索引下推：回表4次；
![[Pasted image 20231230225009.png]]
## 有索引下推：回表两次；
![[Pasted image 20231230225053.png]]