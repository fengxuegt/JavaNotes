
# 如何设计一款关系型数据库？

从底层到高层的思路：
	首先是底层数据的存储管理，一般是由页或者块来进行存储，因为io的速度比较慢
	其次要引入缓存机制；
	还有sql解析模块，用于解析sql语句
	权限划分
	容灾机制
	索引模块
	锁模块
	日志管理
	[[binlog的实现方式]]


# 索引模块

## 为什么不能用二叉查找树

因为每个节点的节点个数太少了。树的层数太多，每个节点都是一个块，都会有一次io请求。

使用B树或者B+树能够有效减少树的层数。每个块的节点数很多。可以提升性能。


## B树的定义

[[B树]]

[[B+树]]

## hash索引

不能进行范围查询


## bit map索引

某个字段只有几种值
锁的粒度很高


## 密集索引

每个搜索码都对应一个索引值
稀疏索引仅仅为索引码的某些值建立索引项


## InnoDB

若是有主键，那么主键就是密集索引
若没有主键，则表的第一个唯一非空索引则为密集索引
若不满足以上条件，InnoDB内部会生成一个隐藏主键（密集索引）

InnoDB的索引和数据是同一个文件；
存储于ibd文件中


MyISAM的索引和数据是分开的；
索引是MYI，数据是MYD



# 四个问题

## 为什么使用索引？

索引能够避免全表扫描，提高查询效率


## 什么样的信息能够成为索引？

具有唯一性的字段

## 索引的数据结构

B+树
bitmap
hash


## 密集索引和稀疏索引的区别




# 如何定位并优化慢sql

根据慢日志定位慢查询sql
与慢日志有关的变量

```sql
show variables like '%quer%';
show status like '%slow_queries%'; // 慢sql的条数

set global slow_query_log = on; // 将慢日志开关打开
set global long_query_time = 1; // 慢查询阈值设置成1s，设置完了之后要重新连接客户端


select count(id) from person_info_large force index (primary); // force index是强制走哪个索引

```

![[Pasted image 20230924214613.png]]

mysql的查询优化器；
决定走哪个索引。

## 联合索引之最左匹配原则























































