## volatile的应用
是轻量级的synchronized，在多处理器开发中保证了共享变量的“可见性”。可见性的意思就是当一个线程修改一个共享变量时，另外一个线程能够读到这个修改的值。

比synchronized执行成本更低，因为不涉及到上下文切换和调度。

## volatile的定义和实现原理

如果一个字段被声明为volatile，那么Java线程模型保证所有线程看到这个变量的值是一致的
当对一个volatile修饰的属性进行修改时，看下汇编指令，发现多了一条lock前缀的指令。
这条指令的意义就是：
- 将当前处理器缓存行中的数据写会到系统内存
- 写回内存的操作会使得在其他cpu里面缓存了该内存地址的数据无效
什么意思呢？就是说每个cpu都是有自己的缓存的，并不是直接跟内存进行操作。但是缓存并不一定什么时候会写回到内存。通过缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，能够保证其他cpu里面的数据都失效，再读取的时候就会从内存中读取。

### volatile的两条实现原则
#### Lock前缀指令会引起处理器缓存回写到内存

#### 一个处理器的缓存回写到内存会导致其他处理器的缓存无效

## volatile的使用优化
![[Pasted image 20240126235955.png]]

### 是不是使用的时候都需要追加到64字节呢
#### 缓存行非64字节的处理器

#### 共享变量不会频繁的写

## synchronized的实现原理与应用
Java中的每个对象都可以作为锁，具体表现为以下三种形式：
- 普通方法——当前实例对象
- 静态方法——当前类的Class对象
- 代码块——括号中配置的对象
线程访问同步代码块时，必须获得锁，退出或者抛出异常时，必须释放锁

代码块的同步是通过monitorenter和monitorexit指令来实现的，jvm保证这两个指令是成对出现的

任何对象都有一个monitor与之关联，当且一个monitor被持有后，就将处于锁定状态。

### Java对象头
如果是数组类型，3个字宽存储对象头，否则两个字宽处理对象头
Mark word        对象类型数据的指针      数组长度    （3字）
Java对象头mark word中默认存储Java对象的hashcode、分代年龄和锁标记位。

![[Pasted image 20240127001339.png]]

### 锁的升级与对比

无锁   偏向锁  轻量级锁   重量级锁
锁只能升级，不能降级






