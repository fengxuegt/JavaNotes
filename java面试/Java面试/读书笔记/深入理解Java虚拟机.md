
## 对象已死？

### 引用计数算法

主要原因是，这个看似简单 的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数 就很难解决对象之间相互循环引用的问题。


### 可达性分析算法

GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系继续向下搜索，搜索过程中走过的路径称为“引用链”，如果某个对象到GC Roots之间没有任何引用链相连接，或者用图论的话来说就是从GC Roots 到这个对象不可达时，就证明此对象不再被使用。

可以作为GC Roots 的对象：
	虚拟机栈中引用的对象，例如参数、局部变量、临时变量等

在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
方法区中常量引用的对象
本地方法中引用的对象
虚拟机内部的引用
所有被同步锁持有的对象


### 再谈引用

#### 强引用
传统引用，只要强引用还在，那么垃圾收集永远不会收集被引用的对象

#### 软引用
一些还有用，但非必须的对象。要抛出OOM之前进行回收，如果还是不够，那么再抛出OOM异常

#### 弱引用

更弱一些，只能生存到下一次垃圾收集发生为止，意思就是只要垃圾收集器开始回收内存，不管内存是否足够，都会进行回收

#### 虚引用

完全没有任何影响。只是为了这个对象被回收时能收到一个系统通知

### 生存还是死亡？

可达性分析不可达的对象，会被第一次标记，随后进行一次筛选。筛选的标准是是否有必要执行finalize方法。
如果已经被调用过或者没有重写finalize方法，那么都会被认为没有必要执行。

如果对象确定要执行finalize方法，那么对象会被放入到一个叫做F-queue的队列之中。并由一个线程去挨个调用他们的finalize方法。
稍后收集器将对F-queue中的对象进行第二次小规模的标记，如果成功在finalize方法中拯救自己，那么就不必被回收。

建议忘记finalize这个方法

### 回收方法区

主要回收两部分内容：废弃的常量+不再使用的类型

判断一个类不再被使用的条件非常苛刻：
- 所有实例都被回收
- 加载该类的加载器已经被回收
- 对应的Class对象没有任何地方被引用


## 垃圾收集算法

#### 引用计数式垃圾收集


#### 追踪式垃圾收集

### 分代收集理论

- 弱分代假说：绝大多数对象都是朝生夕灭的
- 强分代假说：熬过多次垃圾收集过程的对象就越难以消亡
- 跨代引用假说：跨代引用相对于同代引用来说占极少数

新生代会有一个全局的数据结构；这结构把老年代分成若干小块，标识出老年代哪一块内存会存在跨代引用。

新生代收集：Minor GC Young GC
老年代收集：Major GC Old GC

混合收集： Mixed GC
整堆收集： Full GC

### 标记清除算法




